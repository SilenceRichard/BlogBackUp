---
title: http&https
date: 2021-01-19 22:00:44
tags:
  - 读书笔记
---

> 透彻理解http和https
> 
> [参考文章 链接](https://zhuanlan.zhihu.com/p/43789231)

# 网络请求篇

## http

  - dns解析
  - 建立tcp连接
  - 发送http请求
  - 服务器处理请求
  - 返回响应结果
  - 关闭tcp连接

### dns解析

> DNS全称 Domain Name System (域名系统)， 存储了`域名和IP地址的映射`

下面是一个获取www.163.com的ip地址的过程

1. 访问`本地服务器`，查看dns地址是否有缓存
2. 访问`根服务器`，根服务器不会存储域名和ip地址的映射关系，但会告诉你域名所属的域服务器 （如例子，请求的对象属于`.com`域服务器）
3. 访问`域服务器`，返回域名所属的解析服务器
4. 访问`解析服务器`,返回正确的ip地址

`TTL`参数，（time to live）,告诉服务器ip地址在本地缓存生效的时间，加速用户访问

### tcp连接

> tcp的连接建立，连接关闭，都是通过`请求`、`响应`完成的

- TCP的标记

  > tcp层的flag字段有以下标示

    - SYN 建立连接
    - FYN 关闭连接
    - ACK 表示响应
    - PSH 表示有DATA数据传输，
    - RST 表示连接重置。

- 三次握手

  第一次握手：client `(SYN=1, seq=x)`
  
  主机A发送位码为`SYN=1`,并随机产生一个序列号`sequence number` = 1234xxx, 主机B由SYN=1知道，主机A要`建立连接`

  第二次握手：server `(ACK=1, ACKnumber=x+1, seq=y)`
  
  主机B收到消息后，向主机A发送`ack number` = seq + 1, SYN=1, `ACK`=1, 并随机产生一个`seq` = 5678

  第三次握手：client `ACKnumber = y + 1, ACK=1`
  
  主机A收到消息后，检查`ack number`是否正确，以及`ACK`是否为1，若正确，再次发送`ack number` = (主机B的seq + 1), `ACK` =1, 主机B确认seq与ack=1，建立连接

  `三次握手`
  ![](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)
  
  - 四次挥手

  第一次挥手`(FIN=1，seq=x)`

  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

  发送完毕后，客户端进入 FIN_WAIT_1 状态。

  第二次挥手`(ACK=1，ACKnum=x+1)`

  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

  发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。

  第三次挥手`(FIN=1，seq=y)`

  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。

  发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。

  第四次挥手`(ACK=1，ACKnum=y+1)`

  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。

  服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。

  客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

## https

  - 握手过程

    1. 第一次握手，客户端给出协议版本号，生成的随机码`client random`，支持的加密方式
    2. 服务器确认双方使用的加密方法，并给出数字证书，以及一串服务端生成的随机码`server random`
    3. 客户端确认数字证书有效，并生成一个新的随机数`Premaster secret`,然后根据数字证书的公钥加密这串随机数
    4. 服务端使用自己的私钥，获取浏览器发来的随机数`Premaster secret`.
    5. 客户端和服务器根据约定的加密方法，使用前面的三个随机数`client random`, `server random`,`Premaster secret`,生成对话密钥`session key`, 用来加密接下来的对话过程

  - 对称加密
  
    有一个密钥，可以加密对话的内容，加密的内容只能用它才能解密。和日常生活中钥匙的上锁和解锁类似

      - 用对称加密安全吗

        如果对话双方都持有同一密钥，且不被第三者知晓，这个过程是安全的，对称加密的弊端在于`密钥传输过程中会被劫持`

        当然如果一个客户端能够预存所有server的密钥，且确保不被外人知晓，这个过程是安全的。

  - 非对称加密

    有两把密钥，通常一把叫`公钥`，一把叫`私钥`，用公钥加密的内容必须用私钥才能解开，同样的，用私钥加密的内容只有公钥才能解开。
    
    一组公钥私钥，可以保证`单个方向`传输的安全性
    
    - 为什么https没有采用纯对称加密的方式传输？

     因为每次非对称加密算法的计算非常耗时，特别是加密一些较大数据的时候有些力不从心。

  - 非对称加密 + 对称加密

    1. 某服务器拥有非对称加密的公钥A,私钥A
    2. 浏览器请求服务器，服务器把公钥A明文传输给浏览器
    3. 浏览器随机生成一个对称加密的密钥x,用公钥A加密
    4. 服务器拿到后用私钥A解密得到密钥x
    5. 这样双方都拥有密钥x，且别人无法知道它。之后双方的所有数据用密钥x加密解密。

  - 中间人攻击

    1. 某服务器拥有非对称加密的公钥A,私钥A
    2. 浏览器请求服务器，服务器把公钥A明文传输给浏览器
    3. 中间人劫持公钥A，保存下来，把数据包中的公钥A替换为自己伪造的公钥B (中间人有公钥B,对应的有私钥B)
    4. 浏览器生成一个密钥x，用公钥B加密传输
    5. 中间人劫持后用私钥B解密得到密钥X,再用公钥A加密后传给服务器
    6. 服务器拿到后用私钥A解密得到密钥X

    根本原因： **浏览器无法确认收到的公钥是不是网站自己的**

 - 数字证书

    1. 服务器在使用https之前，需要向`CA机构`申请颁发一份数字证书，数字证书里有证书持有者，证书持有者的公钥等信息
    2. 服务器将证书传输给浏览器，浏览器从证书里取公钥


![ssl握手过程](https://pic2.zhimg.com/80/v2-a0d10af45e785fe8d3f5cd12f8c309f5_1440w.jpg)